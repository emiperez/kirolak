package com.kirolak;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;

import org.hibernate.LazyInitializationException;

import com.kirolak.dao.TeamDAO;

// Generated 30-nov-2007 8:26:55 by Hibernate Tools 3.2.0.CR1

/**
 * Group generated by hbm2java
 */
public class Group extends KirolakObject
{
	private Stage stage;
	private Set<Team> teams = new HashSet<Team>();
	private short lastPlayedRound;

	public Group()
	{
		this.id = -1;
	}

	public Group(int id, String name)
	{
		this.id = id;
		this.name = name;
	}

	public Group(int id, Stage stage, String name)
	{
		this.id = id;
		this.stage = stage;
		this.name = name;
	}

	public int getId()
	{
		return this.id;
	}
	
	public void setId(int id)
	{
		this.id = id;
	}

	public Stage getStage()
	{
		return stage;
	}

	public void setStage(Stage stage)
	{
		this.stage = stage;
	}

	public Set<Team> getTeams()
	{
		return teams;
	}

	public void setTeams(Set<Team> teams)
	{
		this.teams = teams;
	}
	
	public String getTeamNames()
	{
		String returnValue = "";
		Iterator<Team> iterator = getTeams().iterator();
		if(iterator.hasNext())
		{
			returnValue = iterator.next().getName();
			while(iterator.hasNext())
			{
				returnValue += ", " + iterator.next().getName();
			}
		}
		return returnValue;
	}
	
	public List<Round> calculateSchedule()
	{
		List<Round> roundList = new ArrayList<Round>();
		List<KirolakObject> teamList = new ArrayList<KirolakObject>();
		try
		{
			Iterator<Team> teamIterator = this.teams.iterator();
			while(teamIterator.hasNext())
			{
				teamList.add(teamIterator.next());
			}
		}
		//TODO: Find out why this Exception is happening
		catch(LazyInitializationException lazy)
		{
			teamList = TeamDAO.listByGroup(this);
		}
		int teamCount = teamList.size();
		if (teamCount > 0)
		{
			// Round-Robin Algorithm
			
			Team firstTeam = (Team)teamList.get(0);
			teamList.remove(0);
			// Add a Null team if the number of teams is not an even number
			if((teamCount % 2) > 0)
			{
				teamList.add(null);
				++teamCount;
			}
			
			// The number of rounds
			int beginTeam = (new Random()).nextInt(teamCount);
			short roundNumber = 1;
			while(roundNumber < teamCount)
			{
				Round currentRound = new Round(new RoundId(roundNumber,this));
				
				Match match = new Match();
				
				// Rotate Home - visiting for the first Team
				if(roundNumber % 2 == 0)
				{
					match.setHomeTeam(firstTeam);
					match.setVisitingTeam((Team)teamList.get( (roundNumber+beginTeam)%(teamCount-1) ));
				}
				else
				{
					match.setHomeTeam((Team)teamList.get( (roundNumber+beginTeam)%(teamCount-1) ));
					match.setVisitingTeam(firstTeam);
				}
				currentRound.addMatch(match);
			
				for (int teamNumber = 1; teamNumber < (teamCount)/2; teamNumber++)
				{
					match = new Match();
					
					// Rotate Home - visiting for the each Team
					if(roundNumber % 2 == 0)
					{
						match.setHomeTeam((Team)teamList.get( (roundNumber + beginTeam + teamNumber) % (teamCount-1) ));
						match.setVisitingTeam((Team)teamList.get( (roundNumber + teamCount + beginTeam - teamNumber -1 )%(teamCount-1)));
					}
					else
					{
						match.setHomeTeam((Team)teamList.get( (roundNumber + teamCount + beginTeam - teamNumber -1  )%(teamCount-1) ));
						match.setVisitingTeam((Team)teamList.get( (roundNumber + beginTeam + teamNumber) % (teamCount-1) ));
					}
					currentRound.addMatch(match);
				}
				roundList.add(currentRound);
				++roundNumber;
			}
			
			// When the same teams play more than once in the current stage.
			for(int n=1;n < this.stage.getMatches(); n++)
			{
				// Rounds per encounter
				for(int i=0 ; i<(teamCount-1) ; i++)
				{
					Round round = new Round(new RoundId(roundNumber,this));
					List<Match> newMatches = new ArrayList<Match>();
					Iterator<Match> iterator = roundList.get(i).getMatches().iterator();
					while(iterator.hasNext())
					{
						Match newMatch = new Match();
						Match currentMatch = iterator.next();
						// Rotate home / visiting for Even encounters.
						if(n % 2 > 0)
						{
													
							newMatch.setHomeTeam(currentMatch.getVisitingTeam());
							newMatch.setVisitingTeam(currentMatch.getHomeTeam());
						}
						else
						{
							newMatch.setHomeTeam(currentMatch.getHomeTeam());
							newMatch.setVisitingTeam(currentMatch.getVisitingTeam());
						}
						newMatches.add(newMatch);
					}
					round.setMatches(newMatches);
					roundList.add(round);
					roundNumber++;
				}
			}
		}
		return roundList;
	}

	public short getLastPlayedRound()
	{
		return lastPlayedRound;
	}

	public void setLastPlayedRound(short lastPlayedRound)
	{
		this.lastPlayedRound = lastPlayedRound;
	}

}
